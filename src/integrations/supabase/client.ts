
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://paqlcflzhjpgvlgcfrfj.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBhcWxjZmx6aGpwZ3ZsZ2NmcmZqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDMzNzAxNTcsImV4cCI6MjA1ODk0NjE1N30.vY9srLDEWl7DlS9afRxiPJ7WJ-AZFWlK-C4dqt-M2T0";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    persistSession: true,
    autoRefreshToken: true,
    detectSessionInUrl: true
  },
  global: {
    fetch: function(input, init) {
      // Add a custom timeout for fetch requests
      const timeoutPromise = new Promise((_, reject) => {
        const timeoutId = setTimeout(() => {
          clearTimeout(timeoutId);
          reject(new Error('Request timed out'));
        }, 8000); // 8 second timeout
      });

      // Race between the fetch and the timeout
      return Promise.race([
        fetch(input, init),
        timeoutPromise
      ]).then(response => {
        // Explicitly type the response as Response to fix the TypeScript error
        const typedResponse = response as Response;
        if (!typedResponse.ok) {
          throw new Error(`HTTP error! status: ${typedResponse.status}`);
        }
        return typedResponse;
      }).catch(error => {
        console.error('Fetch error:', error);
        throw error;
      });
    }
  }
});

// Add a function to check connection status with retry
export const checkSupabaseConnection = async (retries = 2, delay = 1000) => {
  for (let attempt = 0; attempt <= retries; attempt++) {
    try {
      console.log(`Connection attempt ${attempt + 1}/${retries + 1}`);
      
      // Set a timeout for the entire connection check operation
      const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => reject(new Error('Connection check timed out')), 5000);
      });
      
      // Race between the actual check and timeout
      const result = await Promise.race([
        supabase.from('profiles').select('id').limit(1),
        timeoutPromise
      ]);
      
      // If we've reached here, the connection was successful
      console.log('Connection successful:', result);
      return true;
    } catch (e) {
      console.error(`Connection attempt ${attempt + 1} failed:`, e);
      
      // If we have retries left, wait before trying again
      if (attempt < retries) {
        console.log(`Retrying in ${delay}ms...`);
        await new Promise(resolve => setTimeout(resolve, delay));
      } else {
        console.error('All connection attempts failed');
        return false;
      }
    }
  }
  return false;
};

// Export a modified version of the supabase client with better error handling for queries
export const safeQuery = async (queryFn: () => Promise<any>, defaultValue: any = null) => {
  try {
    const { data, error } = await queryFn();
    if (error) throw error;
    return data || defaultValue;
  } catch (error) {
    console.error('Supabase query error:', error);
    return defaultValue;
  }
};
